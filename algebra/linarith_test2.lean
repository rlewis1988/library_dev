
import .linarith 
open expr tactic rb_map list matrix
exit
example (x y : ℤ) 
  (h1 : 2*x + 4*y ≤ 4) (h2 : (-1)*x ≤ 1)
  (h3 : (-1)*y ≤ -5) : false := by not_exists_of_linear_hyps [`h1, `h2, `h3]

example (x y : ℤ) 
  (h1 : 2*x + 4*y ≤ 4) (h2 : (-1)*x ≤ 1)
  (h3 : (-1)*y ≤ -5) : false := by not_exists_of_linear_hyps [`h1, `h2, `h3]
example (x y : ℤ) 
  (h1 : 2*x + 4*y ≤ 4) (h2 : (-1)*x ≤ 1)
  (h3 : (-1)*y ≤ -5) : false := by not_exists_of_linear_hyps [`h1, `h2, `h3]
example (x y : ℤ) 
  (h1 : 2*x + 4*y ≤ 4) (h2 : (-1)*x ≤ 1)
  (h3 : (-1)*y ≤ -5) : false := by not_exists_of_linear_hyps [`h1, `h2, `h3]
example (x y : ℤ) 
  (h1 : 2*x + 4*y ≤ 4) (h2 : (-1)*x ≤ 1)
  (h3 : (-1)*y ≤ -5) : false := by not_exists_of_linear_hyps [`h1, `h2, `h3]
example (x y : ℤ) 
  (h1 : 2*x + 4*y ≤ 4) (h2 : (-1)*x ≤ 1)
  (h3 : (-1)*y ≤ -5) : false := by not_exists_of_linear_hyps [`h1, `h2, `h3]
example (x y : ℤ) 
  (h1 : 2*x + 4*y ≤ 4) (h2 : (-1)*x ≤ 1)
  (h3 : (-1)*y ≤ -5) : false := by not_exists_of_linear_hyps [`h1, `h2, `h3]
example (x y : ℤ) 
  (h1 : 2*x + 4*y ≤ 4) (h2 : (-1)*x ≤ 1)
  (h3 : (-1)*y ≤ -5) : false := by not_exists_of_linear_hyps [`h1, `h2, `h3]
example (x y : ℤ) 
  (h1 : 2*x + 4*y ≤ 4) (h2 : (-1)*x ≤ 1)
  (h3 : (-1)*y ≤ -5) : false := by not_exists_of_linear_hyps [`h1, `h2, `h3]
example (x y : ℤ) 
  (h1 : 2*x + 4*y ≤ 4) (h2 : (-1)*x ≤ 1)
  (h3 : (-1)*y ≤ -5) : false := by not_exists_of_linear_hyps [`h1, `h2, `h3]
example (x y : ℤ) 
  (h1 : 2*x + 4*y ≤ 4) (h2 : (-1)*x ≤ 1)
  (h3 : (-1)*y ≤ -5) : false := by not_exists_of_linear_hyps [`h1, `h2, `h3]
example (a b c d e f g : ℤ)
 (h1 : 1*a + 2*b + 3*c + 4*d + 5*e + 6*f + 7*g ≤ 30)
 (h2 : (-1)*a ≤ 4)
 (h3 : (-1)*b + (-2)*d ≤ -4)
 (h4 : (-1)*c + (-2)*f ≤ -5)
 (h5 : (-1)*e ≤ -3)
 (h6 : (-1)*g ≤ -2) : false :=
by not_exists_of_linear_hyps [`h1, `h2, `h3, `h4, `h5, `h6]
example (a b c d e f g : ℤ)
 (h1 : 1*a + 2*b + 3*c + 4*d + 5*e + 6*f + 7*g ≤ 30)
 (h2 : (-1)*a ≤ 4)
 (h3 : (-1)*b + (-2)*d ≤ -4)
 (h4 : (-1)*c + (-2)*f ≤ -5)
 (h5 : (-1)*e ≤ -3)
 (h6 : (-1)*g ≤ -2) : false :=
by not_exists_of_linear_hyps [`h1, `h2, `h3, `h4, `h5, `h6]
theorem tester8 (a b c d e f g : ℤ)
 (h1 : 1*a + 2*b + 3*c + 4*d + 5*e + 6*f + 7*g ≤ 30)
 (h2 : (-1)*a ≤ 4)
 (h3 : (-1)*b + (-2)*d ≤ -4)
 (h4 : (-1)*c + (-2)*f ≤ -5)
 (h5 : (-1)*e ≤ -3)
 (h6 : (-1)*g ≤ -2) : false :=
by not_exists_of_linear_hyps [`h1, `h2, `h3, `h4, `h5, `h6]
example (a b c d e f g : ℤ)
 (h1 : 1*a + 2*b + 3*c + 4*d + 5*e + 6*f + 7*g ≤ 30)
 (h2 : (-1)*a ≤ 4)
 (h3 : (-1)*b + (-2)*d ≤ -4)
 (h4 : (-1)*c + (-2)*f ≤ -5)
 (h5 : (-1)*e ≤ -3)
 (h6 : (-1)*g ≤ -2) : false :=
by not_exists_of_linear_hyps [`h1, `h2, `h3, `h4, `h5, `h6]
example (a b c d e f g : ℤ)
 (h1 : 1*a + 2*b + 3*c + 4*d + 5*e + 6*f + 7*g ≤ 30)
 (h2 : (-1)*a ≤ 4)
 (h3 : (-1)*b + (-2)*d ≤ -4)
 (h4 : (-1)*c + (-2)*f ≤ -5)
 (h5 : (-1)*e ≤ -3)
 (h6 : (-1)*g ≤ -2) : false :=
by not_exists_of_linear_hyps [`h1, `h2, `h3, `h4, `h5, `h6]
example (a b c d e f g : ℤ)
 (h1 : 1*a + 2*b + 3*c + 4*d + 5*e + 6*f + 7*g ≤ 30)
 (h2 : (-1)*a ≤ 4)
 (h3 : (-1)*b + (-2)*d ≤ -4)
 (h4 : (-1)*c + (-2)*f ≤ -5)
 (h5 : (-1)*e ≤ -3)
 (h6 : (-1)*g ≤ -2) : false :=
by not_exists_of_linear_hyps [`h1, `h2, `h3, `h4, `h5, `h6]


exit


def tester8 (x y z v w : ℤ)
  (h1 : 3*x + 4*y + 5*z + 6*w + 7*v ≤ 30) (h2 : (-2)*y + (-3)*w ≤ -5)
  (h3 : (-1)*x ≤ -3) (h4 : (-1)*z ≤ -1) (h5 : (-1)*v ≤ -1) : false := by do
 h1 ← get_local `h1,
 h2 ← get_local `h2,
 h3 ← get_local `h3,
 h4 ← get_local `h4,
 h5 ← get_local `h5,
 h1t ← infer_type h1,
 h2t ← infer_type h2,
 h3t ← infer_type h3,
 h4t ← infer_type h4,
 h5t ← infer_type h5,
 let vars := keys (find_vars_in_comps [h1t, h2t, h3t, h4t, h5t]) in do
-- trace ("vars", vars),
 h1e ← expand_ineq_proof h1 vars,
 h2e ← expand_ineq_proof h2 vars,
 h3e ← expand_ineq_proof h3 vars,
 h4e ← expand_ineq_proof h4 vars,
 h5e ← expand_ineq_proof h5 vars,
 h1et ← infer_type h1e,
 h2et ← infer_type h2e,
 h3et ← infer_type h3e,
 h4et ← infer_type h4e,
 h5et ← infer_type h5e,
 vars' ← flatten_expr_list vars,
 --pr ← expand_ineq_proof h1 vars,
-- trace ("pr", pr),
 --prtp ← infer_type pr,
 --trace ("prtype", prtp),
 (mat, vec) ← create_farkas_matrix [h1t, h2t, h3t, h4t, h5t] vars,
 --trace ("mat", mat),
 mat' ← flatten_matrix mat,
-- trace ("mat'", mat'),
 vec' ← flatten_expr_list vec,
-- trace ("vec'", vec'),
 realmat ← tactic.to_expr `(matrix_of_list_of_lists %%mat' 5 (length %%vars')),
 trace ("realmat", realmat),
 varvec ← to_expr `(cvector_of_list %%vars'),
 rhsvec ← to_expr `(cvector_of_list %%vec'),
 rvec ← to_expr `(rvector_of_list [(1 : ℤ), 2, 3, 5, 7]),
 zd ← to_expr `((dec_trivial : ∀ i, r_ith (%%rvec ⬝ %%realmat) i = 0)),
 zor ← to_expr `((dec_trivial : c_dot ((%%rvec)^Tr) %%rhsvec < 0)),
 nex ← to_expr `(motzkin_transposition_le %%realmat %%rhsvec %%rvec %%zd %%zor),
 apply nex,
 existsi varvec,
 dp ← to_expr `(%%realmat ⬝ %%varvec),
 pred ← to_expr `(λ i, c_ith %%dp i ≤ c_ith %%rhsvec i),
 conj ← to_expr `(and_of_map %%pred),
 --trace ("conj", conj),
 --test ← to_expr `((rfl : %%conj = %%conj2)),
 conjpr ← to_expr `((⟨⟨⟨⟨%%h1e, %%h2e⟩, %%h3e⟩, %%h4e⟩, %%h5e⟩ : %%conj)),
 --tv ← to_expr `(matrix_of_list_of_lists (%%mat') 3 (length (%%vars')) (fin.mk 0 dec_trivial) (fin.mk 0 dec_trivial)),
 --tveq ← to_expr `((rfl : %%tv = 4)), -- THIS DEPENDS ON THE INDETERMINATE VARIABLE ORDER
 --trace tveq,
  apply conjpr

def tester81 (x y z v w : ℤ)
  (h1 : 3*x + 4*y + 5*z + 6*w + 7*v ≤ 30) (h2 : (-2)*y + (-3)*w ≤ -5)
  (h3 : (-1)*x ≤ -3) (h4 : (-1)*z ≤ -1) (h5 : (-1)*v ≤ -1) : false := by do
 h1 ← get_local `h1,
 h2 ← get_local `h2,
 h3 ← get_local `h3,
 h4 ← get_local `h4,
 h5 ← get_local `h5,
 h1t ← infer_type h1,
 h2t ← infer_type h2,
 h3t ← infer_type h3,
 h4t ← infer_type h4,
 h5t ← infer_type h5,
 let vars := keys (find_vars_in_comps [h1t, h2t, h3t, h4t, h5t]) in do
-- trace ("vars", vars),
 h1e ← expand_ineq_proof h1 vars,
 h2e ← expand_ineq_proof h2 vars,
 h3e ← expand_ineq_proof h3 vars,
 h4e ← expand_ineq_proof h4 vars,
 h5e ← expand_ineq_proof h5 vars,
 h1et ← infer_type h1e,
 h2et ← infer_type h2e,
 h3et ← infer_type h3e,
 h4et ← infer_type h4e,
 h5et ← infer_type h5e,
 vars' ← flatten_expr_list vars,
 --pr ← expand_ineq_proof h1 vars,
-- trace ("pr", pr),
 --prtp ← infer_type pr,
 --trace ("prtype", prtp),
 (mat, vec) ← create_farkas_matrix [h1t, h2t, h3t, h4t, h5t] vars,
 --trace ("mat", mat),
 mat' ← flatten_matrix mat,
-- trace ("mat'", mat'),
 vec' ← flatten_expr_list vec,
-- trace ("vec'", vec'),
 realmat ← tactic.to_expr `(matrix_of_list_of_lists %%mat' 5 (length %%vars')),
 trace ("realmat", realmat),
 varvec ← to_expr `(cvector_of_list %%vars'),
 rhsvec ← to_expr `(cvector_of_list %%vec'),
 rvec ← to_expr `(rvector_of_list [(1 : ℤ), 2, 3, 5, 7]),
 zd ← to_expr `((dec_trivial : ∀ i, r_ith (%%rvec ⬝ %%realmat) i = 0)),
 zor ← to_expr `((dec_trivial : c_dot ((%%rvec)^Tr) %%rhsvec < 0)),
 nex ← to_expr `(motzkin_transposition_le %%realmat %%rhsvec %%rvec %%zd %%zor),
 apply nex,
 existsi varvec,
 dp ← to_expr `(%%realmat ⬝ %%varvec),
 pred ← to_expr `(λ i, c_ith %%dp i ≤ c_ith %%rhsvec i),
 conj ← to_expr `(and_of_map %%pred),
 --trace ("conj", conj),
 --test ← to_expr `((rfl : %%conj = %%conj2)),
 conjpr ← to_expr `((⟨⟨⟨⟨%%h1e, %%h2e⟩, %%h3e⟩, %%h4e⟩, %%h5e⟩ : %%conj)),
 --tv ← to_expr `(matrix_of_list_of_lists (%%mat') 3 (length (%%vars')) (fin.mk 0 dec_trivial) (fin.mk 0 dec_trivial)),
 --tveq ← to_expr `((rfl : %%tv = 4)), -- THIS DEPENDS ON THE INDETERMINATE VARIABLE ORDER
 --trace tveq,
  apply conjpr
def tester82 (x y z v w : ℤ)
  (h1 : 3*x + 4*y + 5*z + 6*w + 7*v ≤ 30) (h2 : (-2)*y + (-3)*w ≤ -5)
  (h3 : (-1)*x ≤ -3) (h4 : (-1)*z ≤ -1) (h5 : (-1)*v ≤ -1) : false := by do
 h1 ← get_local `h1,
 h2 ← get_local `h2,
 h3 ← get_local `h3,
 h4 ← get_local `h4,
 h5 ← get_local `h5,
 h1t ← infer_type h1,
 h2t ← infer_type h2,
 h3t ← infer_type h3,
 h4t ← infer_type h4,
 h5t ← infer_type h5,
 let vars := keys (find_vars_in_comps [h1t, h2t, h3t, h4t, h5t]) in do
-- trace ("vars", vars),
 h1e ← expand_ineq_proof h1 vars,
 h2e ← expand_ineq_proof h2 vars,
 h3e ← expand_ineq_proof h3 vars,
 h4e ← expand_ineq_proof h4 vars,
 h5e ← expand_ineq_proof h5 vars,
 h1et ← infer_type h1e,
 h2et ← infer_type h2e,
 h3et ← infer_type h3e,
 h4et ← infer_type h4e,
 h5et ← infer_type h5e,
 vars' ← flatten_expr_list vars,
 --pr ← expand_ineq_proof h1 vars,
-- trace ("pr", pr),
 --prtp ← infer_type pr,
 --trace ("prtype", prtp),
 (mat, vec) ← create_farkas_matrix [h1t, h2t, h3t, h4t, h5t] vars,
 --trace ("mat", mat),
 mat' ← flatten_matrix mat,
-- trace ("mat'", mat'),
 vec' ← flatten_expr_list vec,
-- trace ("vec'", vec'),
 realmat ← tactic.to_expr `(matrix_of_list_of_lists %%mat' 5 (length %%vars')),
 trace ("realmat", realmat),
 varvec ← to_expr `(cvector_of_list %%vars'),
 rhsvec ← to_expr `(cvector_of_list %%vec'),
 rvec ← to_expr `(rvector_of_list [(1 : ℤ), 2, 3, 5, 7]),
 zd ← to_expr `((dec_trivial : ∀ i, r_ith (%%rvec ⬝ %%realmat) i = 0)),
 zor ← to_expr `((dec_trivial : c_dot ((%%rvec)^Tr) %%rhsvec < 0)),
 nex ← to_expr `(motzkin_transposition_le %%realmat %%rhsvec %%rvec %%zd %%zor),
 apply nex,
 existsi varvec,
 dp ← to_expr `(%%realmat ⬝ %%varvec),
 pred ← to_expr `(λ i, c_ith %%dp i ≤ c_ith %%rhsvec i),
 conj ← to_expr `(and_of_map %%pred),
 --trace ("conj", conj),
 --test ← to_expr `((rfl : %%conj = %%conj2)),
 conjpr ← to_expr `((⟨⟨⟨⟨%%h1e, %%h2e⟩, %%h3e⟩, %%h4e⟩, %%h5e⟩ : %%conj)),
 --tv ← to_expr `(matrix_of_list_of_lists (%%mat') 3 (length (%%vars')) (fin.mk 0 dec_trivial) (fin.mk 0 dec_trivial)),
 --tveq ← to_expr `((rfl : %%tv = 4)), -- THIS DEPENDS ON THE INDETERMINATE VARIABLE ORDER
 --trace tveq,
  apply conjpr
def tester83 (x y z v w : ℤ)
  (h1 : 3*x + 4*y + 5*z + 6*w + 7*v ≤ 30) (h2 : (-2)*y + (-3)*w ≤ -5)
  (h3 : (-1)*x ≤ -3) (h4 : (-1)*z ≤ -1) (h5 : (-1)*v ≤ -1) : false := by do
 h1 ← get_local `h1,
 h2 ← get_local `h2,
 h3 ← get_local `h3,
 h4 ← get_local `h4,
 h5 ← get_local `h5,
 h1t ← infer_type h1,
 h2t ← infer_type h2,
 h3t ← infer_type h3,
 h4t ← infer_type h4,
 h5t ← infer_type h5,
 let vars := keys (find_vars_in_comps [h1t, h2t, h3t, h4t, h5t]) in do
-- trace ("vars", vars),
 h1e ← expand_ineq_proof h1 vars,
 h2e ← expand_ineq_proof h2 vars,
 h3e ← expand_ineq_proof h3 vars,
 h4e ← expand_ineq_proof h4 vars,
 h5e ← expand_ineq_proof h5 vars,
 h1et ← infer_type h1e,
 h2et ← infer_type h2e,
 h3et ← infer_type h3e,
 h4et ← infer_type h4e,
 h5et ← infer_type h5e,
 vars' ← flatten_expr_list vars,
 --pr ← expand_ineq_proof h1 vars,
-- trace ("pr", pr),
 --prtp ← infer_type pr,
 --trace ("prtype", prtp),
 (mat, vec) ← create_farkas_matrix [h1t, h2t, h3t, h4t, h5t] vars,
 --trace ("mat", mat),
 mat' ← flatten_matrix mat,
-- trace ("mat'", mat'),
 vec' ← flatten_expr_list vec,
-- trace ("vec'", vec'),
 realmat ← tactic.to_expr `(matrix_of_list_of_lists %%mat' 5 (length %%vars')),
 trace ("realmat", realmat),
 varvec ← to_expr `(cvector_of_list %%vars'),
 rhsvec ← to_expr `(cvector_of_list %%vec'),
 rvec ← to_expr `(rvector_of_list [(1 : ℤ), 2, 3, 5, 7]),
 zd ← to_expr `((dec_trivial : ∀ i, r_ith (%%rvec ⬝ %%realmat) i = 0)),
 zor ← to_expr `((dec_trivial : c_dot ((%%rvec)^Tr) %%rhsvec < 0)),
 nex ← to_expr `(motzkin_transposition_le %%realmat %%rhsvec %%rvec %%zd %%zor),
 apply nex,
 existsi varvec,
 dp ← to_expr `(%%realmat ⬝ %%varvec),
 pred ← to_expr `(λ i, c_ith %%dp i ≤ c_ith %%rhsvec i),
 conj ← to_expr `(and_of_map %%pred),
 --trace ("conj", conj),
 --test ← to_expr `((rfl : %%conj = %%conj2)),
 conjpr ← to_expr `((⟨⟨⟨⟨%%h1e, %%h2e⟩, %%h3e⟩, %%h4e⟩, %%h5e⟩ : %%conj)),
 --tv ← to_expr `(matrix_of_list_of_lists (%%mat') 3 (length (%%vars')) (fin.mk 0 dec_trivial) (fin.mk 0 dec_trivial)),
 --tveq ← to_expr `((rfl : %%tv = 4)), -- THIS DEPENDS ON THE INDETERMINATE VARIABLE ORDER
 --trace tveq,
  apply conjpr
def tester84 (x y z v w : ℤ)
  (h1 : 3*x + 4*y + 5*z + 6*w + 7*v ≤ 30) (h2 : (-2)*y + (-3)*w ≤ -5)
  (h3 : (-1)*x ≤ -3) (h4 : (-1)*z ≤ -1) (h5 : (-1)*v ≤ -1) : false := by do
 h1 ← get_local `h1,
 h2 ← get_local `h2,
 h3 ← get_local `h3,
 h4 ← get_local `h4,
 h5 ← get_local `h5,
 h1t ← infer_type h1,
 h2t ← infer_type h2,
 h3t ← infer_type h3,
 h4t ← infer_type h4,
 h5t ← infer_type h5,
 let vars := keys (find_vars_in_comps [h1t, h2t, h3t, h4t, h5t]) in do
-- trace ("vars", vars),
 h1e ← expand_ineq_proof h1 vars,
 h2e ← expand_ineq_proof h2 vars,
 h3e ← expand_ineq_proof h3 vars,
 h4e ← expand_ineq_proof h4 vars,
 h5e ← expand_ineq_proof h5 vars,
 h1et ← infer_type h1e,
 h2et ← infer_type h2e,
 h3et ← infer_type h3e,
 h4et ← infer_type h4e,
 h5et ← infer_type h5e,
 vars' ← flatten_expr_list vars,
 --pr ← expand_ineq_proof h1 vars,
-- trace ("pr", pr),
 --prtp ← infer_type pr,
 --trace ("prtype", prtp),
 (mat, vec) ← create_farkas_matrix [h1t, h2t, h3t, h4t, h5t] vars,
 --trace ("mat", mat),
 mat' ← flatten_matrix mat,
-- trace ("mat'", mat'),
 vec' ← flatten_expr_list vec,
-- trace ("vec'", vec'),
 realmat ← tactic.to_expr `(matrix_of_list_of_lists %%mat' 5 (length %%vars')),
 trace ("realmat", realmat),
 varvec ← to_expr `(cvector_of_list %%vars'),
 rhsvec ← to_expr `(cvector_of_list %%vec'),
 rvec ← to_expr `(rvector_of_list [(1 : ℤ), 2, 3, 5, 7]),
 zd ← to_expr `((dec_trivial : ∀ i, r_ith (%%rvec ⬝ %%realmat) i = 0)),
 zor ← to_expr `((dec_trivial : c_dot ((%%rvec)^Tr) %%rhsvec < 0)),
 nex ← to_expr `(motzkin_transposition_le %%realmat %%rhsvec %%rvec %%zd %%zor),
 apply nex,
 existsi varvec,
 dp ← to_expr `(%%realmat ⬝ %%varvec),
 pred ← to_expr `(λ i, c_ith %%dp i ≤ c_ith %%rhsvec i),
 conj ← to_expr `(and_of_map %%pred),
 --trace ("conj", conj),
 --test ← to_expr `((rfl : %%conj = %%conj2)),
 conjpr ← to_expr `((⟨⟨⟨⟨%%h1e, %%h2e⟩, %%h3e⟩, %%h4e⟩, %%h5e⟩ : %%conj)),
 --tv ← to_expr `(matrix_of_list_of_lists (%%mat') 3 (length (%%vars')) (fin.mk 0 dec_trivial) (fin.mk 0 dec_trivial)),
 --tveq ← to_expr `((rfl : %%tv = 4)), -- THIS DEPENDS ON THE INDETERMINATE VARIABLE ORDER
 --trace tveq,
  apply conjpr
def tester85 (x y z v w : ℤ)
  (h1 : 3*x + 4*y + 5*z + 6*w + 7*v ≤ 30) (h2 : (-2)*y + (-3)*w ≤ -5)
  (h3 : (-1)*x ≤ -3) (h4 : (-1)*z ≤ -1) (h5 : (-1)*v ≤ -1) : false := by do
 h1 ← get_local `h1,
 h2 ← get_local `h2,
 h3 ← get_local `h3,
 h4 ← get_local `h4,
 h5 ← get_local `h5,
 h1t ← infer_type h1,
 h2t ← infer_type h2,
 h3t ← infer_type h3,
 h4t ← infer_type h4,
 h5t ← infer_type h5,
 let vars := keys (find_vars_in_comps [h1t, h2t, h3t, h4t, h5t]) in do
-- trace ("vars", vars),
 h1e ← expand_ineq_proof h1 vars,
 h2e ← expand_ineq_proof h2 vars,
 h3e ← expand_ineq_proof h3 vars,
 h4e ← expand_ineq_proof h4 vars,
 h5e ← expand_ineq_proof h5 vars,
 h1et ← infer_type h1e,
 h2et ← infer_type h2e,
 h3et ← infer_type h3e,
 h4et ← infer_type h4e,
 h5et ← infer_type h5e,
 vars' ← flatten_expr_list vars,
 --pr ← expand_ineq_proof h1 vars,
-- trace ("pr", pr),
 --prtp ← infer_type pr,
 --trace ("prtype", prtp),
 (mat, vec) ← create_farkas_matrix [h1t, h2t, h3t, h4t, h5t] vars,
 --trace ("mat", mat),
 mat' ← flatten_matrix mat,
-- trace ("mat'", mat'),
 vec' ← flatten_expr_list vec,
-- trace ("vec'", vec'),
 realmat ← tactic.to_expr `(matrix_of_list_of_lists %%mat' 5 (length %%vars')),
 trace ("realmat", realmat),
 varvec ← to_expr `(cvector_of_list %%vars'),
 rhsvec ← to_expr `(cvector_of_list %%vec'),
 rvec ← to_expr `(rvector_of_list [(1 : ℤ), 2, 3, 5, 7]),
 zd ← to_expr `((dec_trivial : ∀ i, r_ith (%%rvec ⬝ %%realmat) i = 0)),
 zor ← to_expr `((dec_trivial : c_dot ((%%rvec)^Tr) %%rhsvec < 0)),
 nex ← to_expr `(motzkin_transposition_le %%realmat %%rhsvec %%rvec %%zd %%zor),
 apply nex,
 existsi varvec,
 dp ← to_expr `(%%realmat ⬝ %%varvec),
 pred ← to_expr `(λ i, c_ith %%dp i ≤ c_ith %%rhsvec i),
 conj ← to_expr `(and_of_map %%pred),
 --trace ("conj", conj),
 --test ← to_expr `((rfl : %%conj = %%conj2)),
 conjpr ← to_expr `((⟨⟨⟨⟨%%h1e, %%h2e⟩, %%h3e⟩, %%h4e⟩, %%h5e⟩ : %%conj)),
 --tv ← to_expr `(matrix_of_list_of_lists (%%mat') 3 (length (%%vars')) (fin.mk 0 dec_trivial) (fin.mk 0 dec_trivial)),
 --tveq ← to_expr `((rfl : %%tv = 4)), -- THIS DEPENDS ON THE INDETERMINATE VARIABLE ORDER
 --trace tveq,
  apply conjpr
def tester86 (x y z v w : ℤ)
  (h1 : 3*x + 4*y + 5*z + 6*w + 7*v ≤ 30) (h2 : (-2)*y + (-3)*w ≤ -5)
  (h3 : (-1)*x ≤ -3) (h4 : (-1)*z ≤ -1) (h5 : (-1)*v ≤ -1) : false := by do
 h1 ← get_local `h1,
 h2 ← get_local `h2,
 h3 ← get_local `h3,
 h4 ← get_local `h4,
 h5 ← get_local `h5,
 h1t ← infer_type h1,
 h2t ← infer_type h2,
 h3t ← infer_type h3,
 h4t ← infer_type h4,
 h5t ← infer_type h5,
 let vars := keys (find_vars_in_comps [h1t, h2t, h3t, h4t, h5t]) in do
-- trace ("vars", vars),
 h1e ← expand_ineq_proof h1 vars,
 h2e ← expand_ineq_proof h2 vars,
 h3e ← expand_ineq_proof h3 vars,
 h4e ← expand_ineq_proof h4 vars,
 h5e ← expand_ineq_proof h5 vars,
 h1et ← infer_type h1e,
 h2et ← infer_type h2e,
 h3et ← infer_type h3e,
 h4et ← infer_type h4e,
 h5et ← infer_type h5e,
 vars' ← flatten_expr_list vars,
 --pr ← expand_ineq_proof h1 vars,
-- trace ("pr", pr),
 --prtp ← infer_type pr,
 --trace ("prtype", prtp),
 (mat, vec) ← create_farkas_matrix [h1t, h2t, h3t, h4t, h5t] vars,
 --trace ("mat", mat),
 mat' ← flatten_matrix mat,
-- trace ("mat'", mat'),
 vec' ← flatten_expr_list vec,
-- trace ("vec'", vec'),
 realmat ← tactic.to_expr `(matrix_of_list_of_lists %%mat' 5 (length %%vars')),
 trace ("realmat", realmat),
 varvec ← to_expr `(cvector_of_list %%vars'),
 rhsvec ← to_expr `(cvector_of_list %%vec'),
 rvec ← to_expr `(rvector_of_list [(1 : ℤ), 2, 3, 5, 7]),
 zd ← to_expr `((dec_trivial : ∀ i, r_ith (%%rvec ⬝ %%realmat) i = 0)),
 zor ← to_expr `((dec_trivial : c_dot ((%%rvec)^Tr) %%rhsvec < 0)),
 nex ← to_expr `(motzkin_transposition_le %%realmat %%rhsvec %%rvec %%zd %%zor),
 apply nex,
 existsi varvec,
 dp ← to_expr `(%%realmat ⬝ %%varvec),
 pred ← to_expr `(λ i, c_ith %%dp i ≤ c_ith %%rhsvec i),
 conj ← to_expr `(and_of_map %%pred),
 --trace ("conj", conj),
 --test ← to_expr `((rfl : %%conj = %%conj2)),
 conjpr ← to_expr `((⟨⟨⟨⟨%%h1e, %%h2e⟩, %%h3e⟩, %%h4e⟩, %%h5e⟩ : %%conj)),
 --tv ← to_expr `(matrix_of_list_of_lists (%%mat') 3 (length (%%vars')) (fin.mk 0 dec_trivial) (fin.mk 0 dec_trivial)),
 --tveq ← to_expr `((rfl : %%tv = 4)), -- THIS DEPENDS ON THE INDETERMINATE VARIABLE ORDER
 --trace tveq,
  apply conjpr
def tester87 (x y z v w : ℤ)
  (h1 : 3*x + 4*y + 5*z + 6*w + 7*v ≤ 30) (h2 : (-2)*y + (-3)*w ≤ -5)
  (h3 : (-1)*x ≤ -3) (h4 : (-1)*z ≤ -1) (h5 : (-1)*v ≤ -1) : false := by do
 h1 ← get_local `h1,
 h2 ← get_local `h2,
 h3 ← get_local `h3,
 h4 ← get_local `h4,
 h5 ← get_local `h5,
 h1t ← infer_type h1,
 h2t ← infer_type h2,
 h3t ← infer_type h3,
 h4t ← infer_type h4,
 h5t ← infer_type h5,
 let vars := keys (find_vars_in_comps [h1t, h2t, h3t, h4t, h5t]) in do
-- trace ("vars", vars),
 h1e ← expand_ineq_proof h1 vars,
 h2e ← expand_ineq_proof h2 vars,
 h3e ← expand_ineq_proof h3 vars,
 h4e ← expand_ineq_proof h4 vars,
 h5e ← expand_ineq_proof h5 vars,
 h1et ← infer_type h1e,
 h2et ← infer_type h2e,
 h3et ← infer_type h3e,
 h4et ← infer_type h4e,
 h5et ← infer_type h5e,
 vars' ← flatten_expr_list vars,
 --pr ← expand_ineq_proof h1 vars,
-- trace ("pr", pr),
 --prtp ← infer_type pr,
 --trace ("prtype", prtp),
 (mat, vec) ← create_farkas_matrix [h1t, h2t, h3t, h4t, h5t] vars,
 --trace ("mat", mat),
 mat' ← flatten_matrix mat,
-- trace ("mat'", mat'),
 vec' ← flatten_expr_list vec,
-- trace ("vec'", vec'),
 realmat ← tactic.to_expr `(matrix_of_list_of_lists %%mat' 5 (length %%vars')),
 trace ("realmat", realmat),
 varvec ← to_expr `(cvector_of_list %%vars'),
 rhsvec ← to_expr `(cvector_of_list %%vec'),
 rvec ← to_expr `(rvector_of_list [(1 : ℤ), 2, 3, 5, 7]),
 zd ← to_expr `((dec_trivial : ∀ i, r_ith (%%rvec ⬝ %%realmat) i = 0)),
 zor ← to_expr `((dec_trivial : c_dot ((%%rvec)^Tr) %%rhsvec < 0)),
 nex ← to_expr `(motzkin_transposition_le %%realmat %%rhsvec %%rvec %%zd %%zor),
 apply nex,
 existsi varvec,
 dp ← to_expr `(%%realmat ⬝ %%varvec),
 pred ← to_expr `(λ i, c_ith %%dp i ≤ c_ith %%rhsvec i),
 conj ← to_expr `(and_of_map %%pred),
 --trace ("conj", conj),
 --test ← to_expr `((rfl : %%conj = %%conj2)),
 conjpr ← to_expr `((⟨⟨⟨⟨%%h1e, %%h2e⟩, %%h3e⟩, %%h4e⟩, %%h5e⟩ : %%conj)),
 --tv ← to_expr `(matrix_of_list_of_lists (%%mat') 3 (length (%%vars')) (fin.mk 0 dec_trivial) (fin.mk 0 dec_trivial)),
 --tveq ← to_expr `((rfl : %%tv = 4)), -- THIS DEPENDS ON THE INDETERMINATE VARIABLE ORDER
 --trace tveq,
  apply conjpr
